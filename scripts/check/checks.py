"""
ğŸ“˜ã€å¯ä½¿ç”¨çš„æŒ‡ä»¤æ ¼å¼èˆ‡èªªæ˜ã€‘ğŸ‘‡

æ¯æ¬¡è¼¸å…¥æŒ‡ä»¤å¾Œï¼ŒæŒ‰ Enter åŸ·è¡Œã€‚å¯ä¸€æ¬¡è¼¸å…¥å¤šæ¢æŒ‡ä»¤ï¼Œç”¨è‹±æ–‡åˆ†è™Ÿ ; åˆ†éš”ã€‚
è‹¥ç›´æ¥æŒ‰ Enterï¼Œå‰‡é€²å…¥è²èª¿è™•ç†é‚è¼¯ã€‚

============================
ğŸ›  æŒ‡ä»¤é¡å‹èˆ‡æ ¼å¼ï¼š
============================

1ï¸âƒ£ æ¼¢å­—æ¬„æ›¿æ›/åˆªé™¤ï¼ˆä»¥æŸæ¼¢å­—å®šä½ï¼‰

  c-æ¼¢å­—-æ–°å­—         â¤ å°‡â€œæ¼¢å­—â€æ›¿æ›ç‚ºâ€œæ–°å­—â€
  c-æ¼¢å­—-d            â¤ æ¸…ç©ºè©²è¡Œï¼ˆæ•´è¡Œè¨­ç‚ºç©ºï¼‰

  âœ… ç¯„ä¾‹ï¼š
    c-å¸¥-å¥½            å°‡â€œå¸¥â€å­—æ”¹ç‚ºâ€œå¥½â€
    c-å¸¥-d             æ¸…ç©ºåŒ…å«â€œå¸¥â€çš„é‚£ä¸€æ•´è¡Œ
    c-å¸¥-d-123         æ¸…ç©ºâ€œå¸¥â€æ‰€åœ¨ç¬¬ 123 è¡Œï¼ˆå¤šéŸ³å­—æ™‚éœ€è¦æŒ‡å®šï¼‰

2ï¸âƒ£ éŸ³æ¨™æ¬„æ›¿æ›ï¼ˆä»¥æŸæ¼¢å­—å®šä½ï¼‰

  i-æ¼¢å­—-æ–°éŸ³æ¨™      â¤ å°‡â€œæ¼¢å­—â€æ‰€åœ¨è¡Œçš„éŸ³æ¨™æ¬„æ”¹ç‚ºâ€œæ–°éŸ³æ¨™â€

  âœ… ç¯„ä¾‹ï¼š
    i-å¸¥-jat4          æŠŠâ€œå¸¥â€çš„éŸ³æ¨™æ”¹ç‚º jat4
    i-å¸¥-jat4-123      å¦‚æœâ€œå¸¥â€å‡ºç¾å¤šæ¬¡ï¼Œç”¨é€™å€‹æ–¹å¼æŒ‡å®šç¬¬ 123 è¡Œ

3ï¸âƒ£ éŸ³æ¨™æ¬„å…¨å±€æ›¿æ›ï¼ˆç„¡éœ€æŒ‡å®šæ¼¢å­—ï¼‰

  p-åŸå­—å…ƒ-æ–°å­—å…ƒ     â¤ å°‡éŸ³æ¨™æ¬„ä¸­çš„æ‰€æœ‰â€œåŸå­—å…ƒâ€æ›¿æ›ç‚ºâ€œæ–°å­—å…ƒâ€

  âœ… ç¯„ä¾‹ï¼š
    p-'-Ê°              æŠŠæ‰€æœ‰éŸ³æ¨™ä¸­çš„ ' æ›¿æ›ç‚º Ê°

4ï¸âƒ£ è²èª¿æ›¿æ›ï¼ˆä¾æ“šå°¾éŸ³æ˜¯å¦ç‚ºå…¥è²/èˆ’è²ï¼‰

  råŸ>æ–°             â¤ æ›¿æ›å…¥è²èª¿å€¼ï¼ˆä¾‹ï¼šr031>3 è¡¨ç¤ºæŠŠå…¥è²çš„ 031 æ”¹ç‚º 3ï¼‰
  såŸ>æ–°             â¤ æ›¿æ›èˆ’è²èª¿å€¼ï¼ˆä¾‹ï¼šs25>55 è¡¨ç¤ºæŠŠèˆ’è²çš„ 25 æ”¹ç‚º 55ï¼‰

  âœ… ç¯„ä¾‹ï¼š
    r021>21           å°‡å…¥è²çš„ 021 æ”¹ç‚º 21ï¼ˆ0 é–‹é ­è¦–ç‚ºåŒä¸€çµ„ï¼‰
    s33>55            å°‡èˆ’è²çš„ 33 æ”¹ç‚º 55

5ï¸âƒ£ è™•ç†ä¸¦æ›¿æ›é›¶è²æ¯

    è¡Œè™Ÿ æ›¿æ›æ ¼å¼ï¼ˆåŸ>æ–°ï¼‰

    âœ… ç¯„ä¾‹ï¼š
      0 y>i           â¤ ç¬¬ 0 è¡Œä¸­å°‡ y æ”¹ç‚º i
      1~3 u>wu         â¤ ç¬¬ 1 åˆ° 3 è¡Œçš„è³‡æ–™å°‡ u æ”¹ç‚º wu

6ï¸âƒ£ æŸ¥è©¢è²æ¯æˆ–éŸ»æ¯å¾Œé€²è¡Œä¿®æ”¹ï¼ˆæŸ¥è©¢ä»‹é¢ï¼‰

    ğŸ” å¯è¼¸å…¥ã€Œè²æ¯ / éŸ»æ¯ã€æŸ¥è©¢ï¼ˆå¯å¤šå€‹ï¼‰
    ä¾‹å¦‚ï¼šj i u         â¤ æŸ¥æ‰¾è²æ¯ç‚º jï¼Œæˆ–éŸ»æ¯ç‚º iã€u çš„è³‡æ–™

    æŸ¥è©¢å¾Œä½¿ç”¨æŒ‡ä»¤ï¼š
      è¡Œè™Ÿ æ›¿æ›æŒ‡ä»¤    â¤ ä¾‹å¦‚ï¼š0~2 i>y

  âœ… å¤šç­†æŒ‡ä»¤å¯ç”¨åˆ†è™Ÿ ; ä¸€æ¬¡è¼¸å…¥ï¼š
    p-'-Ê°; r031>3; i-å¸¥-jat4-1355; c-å¸¥-d-1234


============================
âš ï¸ ç‰¹åˆ¥æ³¨æ„ï¼š
============================

- c/i é¡æŒ‡ä»¤è‹¥å®šä½æ¼¢å­—é‡è¤‡ï¼ˆå¤šéŸ³å­—ï¼‰ï¼Œè«‹åŠ ä¸Šã€Œ-è¡Œè™Ÿã€é¿å…æ¨¡ç³Šã€‚
- æ¯æ¬¡æ›¿æ›å¾Œï¼Œç³»çµ±æœƒè‡ªå‹•é¡¯ç¤ºæ‰€æœ‰è²èª¿åˆ†ä½ˆèˆ‡è³‡æ–™æ ¼å¼æª¢æŸ¥çµæœã€‚
- å¤šæ¢æŒ‡ä»¤ç”¨è‹±æ–‡åˆ†è™Ÿ ; åˆ†éš”ã€‚ä¾‹å¦‚ï¼š
    p-'-Ê°; r031>3; i-å¸¥-jat4-1355; c-å¸¥-d-1234

============================
ğŸ“Š æ ¼å¼æª¢æŸ¥èªªæ˜ï¼š
============================

1ï¸âƒ£ éå–®å­—æ¼¢å­—ï¼šæª¢æŸ¥æ¼¢å­—æ¬„æ˜¯å¦ç‚ºå–®å€‹å­—å…ƒ
2ï¸âƒ£ ç¼ºè²èª¿ï¼šéŸ³æ¨™æ¬„è‹¥ç„¡æ­£å¸¸æ•¸å­—æˆ–ä¸Šæ¨™æ•¸å­—çµå°¾ï¼Œæœƒåˆ—ç‚ºç¼ºè²èª¿
3ï¸âƒ£ éŸ³æ¨™ç•°å¸¸ï¼šè‹¥éŸ³æ¨™æ¬„ä¸­å«æœ‰ , . ; ' / - = ç­‰ç¬¦è™Ÿï¼Œä¸”å‰å¾Œä¸ç‚ºæœ‰æ•ˆéŸ³ç¯€ â†’ é¡¯ç¤ºç•°å¸¸

âœ… è‹¥æ‰€æœ‰è³‡æ–™çš†æ­£å¸¸ï¼Œæœƒé¡¯ç¤ºã€Œæ ¼å¼æª¢æŸ¥é€šéï¼Œç„¡ç•°å¸¸ã€

"""
import os
import re
import sys
import tkinter as tk
from collections import defaultdict
from tkinter import filedialog

import pandas as pd

from common.constants import col_map, custom_order
from source.format_convert import process_ç¸£å¿—_word, process_è·³è·³è€é¼ , process_ç¸£å¿—_excel

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))  # æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ° sys.path
from scripts.check.maybe_error_chars import check_get_chars
from source.get_new import extract_all_from_files

RU_FINALS = set("ptkÊ”Ë€áµ–áµáµ—bdg")
SUPER_TO_NORMAL = str.maketrans("â°Â¹Â²Â³â´âµâ¶â·â¸â¹", "0123456789")


def è™•ç†è‡ªå®šç¾©ç·¨è¼¯æŒ‡ä»¤(df, col_hanzi, col_ipa, command):
    results = []
    errors = []

    commands = [cmd.strip() for cmd in command.split(";") if cmd.strip()]
    for cmd in commands:
        if not cmd:
            continue
        parts = cmd.split("-")

        if len(parts) < 3:
            errors.append(f"âŒ ç„¡æ•ˆæŒ‡ä»¤æ ¼å¼ï¼š{cmd}")
            continue

        action = parts[0]
        key = parts[1]
        value = parts[2]
        row_id = int(parts[3]) if len(parts) == 4 and parts[3].isdigit() else None

        # âœ… è™•ç†ã€Œå…¨è¡¨éŸ³æ¨™æ›¿æ›ã€æŒ‡ä»¤ï¼šp-åŸå­—å…ƒ-æ–°å­—å…ƒ
        if action == "p":
            df[col_ipa] = df[col_ipa].astype(str).str.replace(key, value, regex=False)
            results.append(f"âœ… å…¨è¡¨éŸ³æ¨™æ›¿æ›ï¼š{key} â†’ {value}")
            continue

        # âœ… å…¶ä»–æŒ‡ä»¤ï¼ˆéœ€å®šä½æ¼¢å­—ï¼‰
        matches = df[df[col_hanzi] == key]
        if len(matches) == 0:
            errors.append(f"âŒ æ‰¾ä¸åˆ°æ¼¢å­—ï¼š{key}")
            continue
        elif len(matches) > 1 and not row_id:
            ids = matches.index.tolist()
            suggestion = "; ".join([f"{idx} {key}" for idx in ids])
            errors.append(
                f"âš ï¸ æ‰¾åˆ°å¤šå€‹â€œ{key}â€ â†’ è«‹ä½¿ç”¨è¡Œè™Ÿå€åˆ†ï¼š\n"
                + f"â†’ å»ºè­°æŒ‡ä»¤ï¼š{cmd}-{ids[0]} æˆ– {cmd}-{ids[1]} ç­‰\n"
                + suggestion
            )
            continue

        # ğŸ” ç¢ºå®šç›®æ¨™è¡Œ
        target_row = row_id if row_id is not None else matches.index[0]

        if action == "c":
            if value == "d":
                df.loc[target_row] = ""
                results.append(f"âœ… å·²æ¸…ç©ºè¡Œ {target_row}ï¼ˆæ¼¢å­—ï¼š{key}ï¼‰")
            else:
                df.at[target_row, col_hanzi] = value
                results.append(f"âœ… æ›¿æ›æ¼¢å­—ï¼š{key} â†’ {value}ï¼ˆè¡Œ {target_row}ï¼‰")

        elif action == "i":
            df.at[target_row, col_ipa] = value
            results.append(f"âœ… ä¿®æ”¹éŸ³æ¨™ï¼š{key} â†’ {value}ï¼ˆè¡Œ {target_row}ï¼‰")

        else:
            errors.append(f"âŒ ä¸æ”¯æ´çš„æŒ‡ä»¤é¡å‹ï¼š{action}")

    return results, errors


def æª¢æŸ¥è³‡æ–™æ ¼å¼(df, col_hanzi, col_ipa, display=False, col_note=None):
    def is_single_chinese(char):
        return len(char) == 1 and '\u4e00' <= char <= '\u9fff'

    def is_normal_ipa(s):
        allowed = set(
            "abcdefghijklmnopqrstuvwxyz"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "Å‹É‘ÉÉ’É“Ê™Î²É”É•Ã§Ã°É–É—É˜É™ÉšÉ›ÉœÉÉŸÊ„É¡É¢Ê›É£Ê°É¥ÊœÉ¦ÉªÊÉ­É¬É«ÊŸÉ®É°É±É²ÈµÉ³Å‹É³É´ÉµÃ¸Å“Ã¦É¶É¸É¹É»ÊÊ€É½É¾ÊƒÊ‚ÊˆÊŠÊ‹ÊŒÊÏ‡ÊÊ‘ÊÊ’Ê”Ê•Ê¡Ê¢Ê˜ÊÎ¸Ê¼ËˆËŒËË‘â°Â¹Â²Â³â´âµâ¶â·â¸â¹â¿Ë¡Ê²Ê³Ë€"
            "Ê¦Ê§Ê¨Ê‚ÊÊ‘Ê’Ê®Ê°Ê²ËËË Ë¤~^Ìƒ"
            "Ä±Å¿ï‰É©É·Ê…É¥Ê¯ÎµÉÉšá´‡Ã£áº½Ä©á»¹ÃµÃºÎ±É¤áµ˜á¶·á¶¤á¶¶áµšÊ¸á¶¦áµŠâ±â—Œâˆ…É¯Ê¦Ê’É¿ÌÊ·Ì¯Ì©"
            "0123456789"
        )
        return all(c in allowed for c in s)

    errors = {
        "éå–®å­—æ¼¢å­—": [],
        "ç•°å¸¸éŸ³æ¨™": [],
        "ç¼ºè²èª¿": []
    }
    # print(df)
    for i, row in df.iterrows():
        hanzi = str(row.get(col_hanzi, "")).strip()
        ipa = str(row.get(col_ipa, "")).strip()

        if not hanzi or not ipa:
            continue  # è·³éç©ºè¡Œæˆ–ç©ºæ¼¢å­—/éŸ³æ¨™

        if not is_single_chinese(hanzi):
            errors["éå–®å­—æ¼¢å­—"].append((i, hanzi))

        match = re.search(r"[0-9Â¹Â²Â³â´âµâ¶â·â¸â¹â°]{1,4}$", ipa)
        if not match:
            errors["ç¼ºè²èª¿"].append((i, hanzi))
            continue

        if any(sep in ipa for sep in ",;/\\"):
            # å¦‚æœåŒ…å«åˆ†éš”ç¬¦ï¼Œæ‹†åˆ†æˆå¤šä¸ªéƒ¨åˆ†
            parts = re.split(r"[,;/\\]", ipa)
        else:
            # å¦‚æœæ²¡æœ‰åˆ†éš”ç¬¦ï¼Œç›´æ¥å°† ipa å­—ç¬¦ä¸²ä½œä¸ºä¸€ä¸ªæ•´ä½“æ£€æŸ¥
            parts = [ipa]
        if ipa.isdigit():
            errors["ç•°å¸¸éŸ³æ¨™"].append((i, hanzi, ipa))
            continue
        if not all(is_normal_ipa(p.strip()) for p in parts if p.strip()):
            errors["ç•°å¸¸éŸ³æ¨™"].append((i, hanzi, ipa))

    # éŒ¯èª¤è¼¸å‡º
    for k, v in errors.items():
        if v:
            print(f"\nâš ï¸ [{k}] ç™¼ç¾ {len(v)} é …ï¼š")
            count = 0  # ç”¨æ–¼æ§åˆ¶æ¯è¡Œæœ€å¤šé¡¯ç¤º4å€‹éŒ¯èª¤
            for item in v:
                if count == 4:  # æ¯4ä¸ªé”™è¯¯æ¢è¡Œ
                    print()  # æ¢è¡Œ
                    count = 0  # é‡ç½®è®¡æ•°å™¨
                print(item, end="   ")  # ä¸æ¢è¡Œï¼Œæ¡ç›®ä¹‹é—´åŠ ç©ºæ ¼
                count += 1

    if not any(errors.values()):
        print("âœ… æ ¼å¼æª¢æŸ¥é€šéï¼Œç„¡ç•°å¸¸")

    # é¡å¤–ï¼šé¡¯ç¤ºæ¯ä¸€è¡Œå…§å®¹ï¼ˆå¯é¸ï¼‰
    if display:
        print("\nğŸ§¾ æ‰€æœ‰è³‡æ–™ï¼ˆè¡Œè™Ÿï½œæ¼¢å­—ï½œéŸ³æ¨™ï½œè¨»é‡‹ï¼‰ï¼š")
        for i, row in df.iterrows():
            hanzi = str(row.get(col_hanzi, "")).strip()
            ipa = str(row.get(col_ipa, "")).strip()
            note = str(row.get(col_note, "")).strip() if col_note and col_note in row else ""

            # è·³éæ¼¢å­—èˆ‡éŸ³æ¨™éƒ½ç‚ºç©ºçš„è¡Œ
            if not hanzi and not ipa:
                continue

            print(f"[{i}] {hanzi}ï½œ{ipa}ï½œ{note}")


def æ•´ç†ä¸¦é¡¯ç¤ºèª¿å€¼(df_xlsx, actual_cols):
    ru_rawtone_to_hanzi = defaultdict(set)
    shu_tone_to_hanzi = defaultdict(set)

    for _, row in df_xlsx.iterrows():
        ipa = row[actual_cols['éŸ³æ¨™']]
        hanzi = row[actual_cols['æ¼¢å­—']]
        match = re.search(r"([0-9Â¹Â²Â³â´âµâ¶â·â¸â¹â°]{1,4})$", str(ipa))
        if not match:
            continue

        tone_raw = match.group(1)
        tone = tone_raw.translate(SUPER_TO_NORMAL)
        head = ipa[:-len(tone_raw)]
        prev_char = head[-1] if head else ""
        ends_with_ru = prev_char in RU_FINALS

        if ends_with_ru:
            ru_rawtone_to_hanzi[tone].add(hanzi)
        else:
            shu_tone_to_hanzi[tone].add(hanzi)

    # å…¥è²èª¿å€¼é¡¯ç¤ºï¼ˆåˆä½µåŸèª¿å€¼ï¼‰
    merged_ru = defaultdict(lambda: {"raw_tones": set(), "hanzi": set()})
    for t, chars in ru_rawtone_to_hanzi.items():
        key = t.lstrip("0")
        merged_ru[key]["raw_tones"].add(t)
        merged_ru[key]["hanzi"].update(chars)

    print("â–¶ å…¥è²èª¿å€¼ï¼š")
    for key in sorted(merged_ru.keys(), key=lambda x: int(x)):
        label = "/".join(sorted(merged_ru[key]["raw_tones"], key=lambda x: int(x)))
        hanzi_str = "".join(sorted(merged_ru[key]["hanzi"]))
        print(f"{label}: {hanzi_str}")

    print("\nâ–¶ èˆ’è²èª¿å€¼ï¼š")
    for t in sorted(shu_tone_to_hanzi.keys(), key=lambda x: int(x)):
        print(f"{t}: {''.join(sorted(shu_tone_to_hanzi[t]))}")


def è™•ç†æ‰¹æ¬¡ç·¨è¼¯æŒ‡ä»¤(df_xlsx, filtered_df, actual_cols, edit_input):
    results = []
    errors = []

    # æ”¯æ´æ ¼å¼å¦‚ "0 y>i;1~3 o>i"
    commands = [cmd.strip() for cmd in edit_input.split(";") if cmd.strip()]

    for cmd in commands:
        # æ‹†åˆ†ç¯„åœèˆ‡æ›¿æ›æŒ‡ä»¤
        try:
            range_part, replace_part = cmd.split()
        except ValueError:
            errors.append(f"âŒ æ ¼å¼éŒ¯èª¤ï¼Œç¼ºå°‘ç©ºæ ¼åˆ†éš”ï¼š{cmd}")
            continue

        # è§£ææ›¿æ›å…§å®¹ï¼šä¾‹å¦‚ "y>i"
        if ">" not in replace_part:
            errors.append(f"âŒ æ›¿æ›æ ¼å¼éŒ¯èª¤ï¼ˆéœ€ä½¿ç”¨ >ï¼‰ï¼š{cmd}")
            continue
        old, new = replace_part.split(">", 1)

        # è§£æè¡Œè™Ÿç¯„åœ
        if "~" in range_part:
            try:
                start, end = map(int, range_part.split("~"))
                indices = list(range(start, end + 1))
            except:
                errors.append(f"âŒ è¡Œè™Ÿç¯„åœæ ¼å¼éŒ¯èª¤ï¼š{range_part}")
                continue
        else:
            try:
                indices = [int(range_part)]
            except:
                errors.append(f"âŒ è¡Œè™Ÿæ ¼å¼éŒ¯èª¤ï¼š{range_part}")
                continue

        # é€è¡Œè™•ç†
        for i in indices:
            if i < 0 or i >= len(filtered_df):
                errors.append(f"âŒ è¡Œè™Ÿ {i} è¶…å‡ºç¯„åœ")
                continue

            # å–å¾—åŸå§‹è¡Œè™Ÿï¼Œå°æ‡‰å› df_xlsx
            original_index = filtered_df.iloc[i]["åŸå§‹è¡Œè™Ÿ"]

            if original_index not in df_xlsx.index:
                errors.append(f"âŒ æ‰¾ä¸åˆ°åŸå§‹è¡Œ {original_index}ï¼ˆå°æ‡‰æ–¼æ’åºå¾Œç¬¬ {i} è¡Œï¼‰")
                continue

            row_result = f"ğŸ“ ç¬¬ {i} è¡Œï¼ˆåŸå§‹è¡Œ {original_index}ï¼‰ï¼š"

            # è™•ç†æ¯å€‹ç›®æ¨™æ¬„ä½ï¼ˆç›®å‰åƒ…æ¼¢å­—èˆ‡éŸ³æ¨™ï¼‰
            for label, colname in actual_cols.items():
                old_value = df_xlsx.at[original_index, colname]
                new_value = old_value.replace(old, new, 1)
                if new_value != old_value:
                    df_xlsx.at[original_index, colname] = new_value
                    row_result += f"ã€{label}ã€‘{old_value} â†’ {new_value}ï¼›"

            if "ï¼›" in row_result:
                results.append(row_result)
            else:
                results.append(f"ğŸ“ ç¬¬ {i} è¡Œæœªç™¼ç¾å¯æ›¿æ›å…§å®¹ï¼ˆåŸå§‹è¡Œ {original_index}ï¼‰")

    return results, errors


def æŸ¥æ‰¾å‡ºéŸ»å­—(df_xlsx, actual_cols, chars_list):
    num = len(chars_list)
    # æŸ¥æ‰¾å¹¶è¾“å‡ºæŒ‡å®šçš„æ¼¢å­—çš„è®€éŸ³
    print(f"\nğŸ“ ä»¥ä¸‹å­—å¯èƒ½æœ‰èª¤(å‡ºéŸ»),å…±æœ‰{num}å€‹ï¼š")
    count = 0
    for i, row in df_xlsx.iterrows():
        hanzi = str(row.get(actual_cols['æ¼¢å­—'], "")).strip()
        ipa = str(row.get(actual_cols['éŸ³æ¨™'], "")).strip()
        note = str(row.get(actual_cols['è§£é‡‹'], "")).strip()

        # åªæŸ¥æ‰¾åœ¨æŒ‡å®šåˆ—è¡¨ä¸­çš„æ¼¢å­—
        if hanzi in chars_list:
            if count == 4:  # æ¯4ä¸ªæ¡ç›®æ¢è¡Œ
                print()  # æ¢è¡Œ
                count = 0  # é‡ç½®è®¡æ•°å™¨
            print(f"[{i}] {hanzi}ï½œ{ipa}ï½œ{note}", end=" \t\t ")  # ä¸æ¢è¡Œ
            count += 1


def sort_by_custom_order(series):
    counts = series.dropna().astype(str)
    counts = counts[counts != ""]
    value_counts = counts.value_counts()

    def custom_key(token):
        for length in range(3, 0, -1):  # å„ªå…ˆå–3/2å€‹å­—å…ƒç•¶ key
            sub = token[:length]
            if sub in custom_order:
                return custom_order.index(sub)
        return float('inf')

    sorted_series = value_counts.sort_index(key=lambda idx: [custom_key(i) for i in idx])
    return sorted_series


def print_counts_in_rows(counts, per_row=5):
    # å°‡ key:value è½‰ç‚ºå­—ä¸²ä¸¦å°é½Šæ ¼å¼
    max_key_len = max(len(str(k)) for k in counts.index)
    max_val_len = max(len(str(v)) for v in counts.values)

    items = [f"{k:<{max_key_len}}:{v:>{max_val_len}}" for k, v in counts.items()]

    for i in range(0, len(items), per_row):
        print("    ".join(items[i:i + per_row]))


priority_order = ['u', 'i', 'y', 'm', 'p', 'n', 't', 'Å‹', 'k', 'Ê”']
priority_map = {ch: i for i, ch in enumerate(priority_order)}


def rime_sort_key(rime):
    rime = str(rime)

    # 1. æ‰¾å„ªå…ˆåŒ¹é…ç¬¬ä¸€å€‹å­—å…ƒçš„æ¬Šé‡
    first = priority_map.get(rime[0], float('inf')) if len(rime) > 0 else float('inf')
    second = priority_map.get(rime[1], float('inf')) if len(rime) > 1 else float('inf')

    # 2. åˆ¤æ–·æ˜¯å¦æ˜¯å®Œå…¨åŒ¹é…ï¼ˆä¾‹å¦‚åªæ˜¯ä¸€å€‹ "i"ï¼‰
    full_match_bonus = 0 if rime in priority_order else 1  # å®Œå…¨åŒ¹é…çš„å„ªå…ˆ

    # 3. è¿”å›ä¸‰å±¤æ’åºéµï¼šæ˜¯å¦å®Œå…¨åŒ¹é… > ç¬¬ä¸€ç¢¼ > ç¬¬äºŒç¢¼
    return (full_match_bonus, first, second)


def check_all(xlsx_paths, five=False):
    for path in xlsx_paths:
        print(f"\n==== æª”æ¡ˆ: {path} ====")

        try:
            df_xlsx = pd.read_excel(path, dtype=str).fillna('')
        except Exception as e:
            print(f"âŒ ç„¡æ³•è®€å– Excel æª”æ¡ˆ: {path}")
            continue

        actual_cols = {}
        for key, candidates in col_map.items():
            for name in candidates:
                if name in df_xlsx.columns:
                    actual_cols[key] = name
                    break

        if 'éŸ³æ¨™' not in actual_cols or 'æ¼¢å­—' not in actual_cols:
            print("âŒ æ‰¾ä¸åˆ°éŸ³æ¨™æˆ–æ¼¢å­—æ¬„ä½")
            continue

        æª¢æŸ¥è³‡æ–™æ ¼å¼(df_xlsx, actual_cols['æ¼¢å­—'], actual_cols['éŸ³æ¨™'], False)

        # ğŸ” ç¬¬ä¸€éšæ®µï¼šè™•ç†è‡ªå®šç¾©ç·¨è¼¯æŒ‡ä»¤
        while True:
            edit_input = input("\nâœï¸ è¼¸å…¥ç·¨è¼¯æŒ‡ä»¤ ï¼ŒæŒ‰ Enter è·³éï¼š").strip()
            if not edit_input:
                break
            results, errors = è™•ç†è‡ªå®šç¾©ç·¨è¼¯æŒ‡ä»¤(df_xlsx, actual_cols['æ¼¢å­—'], actual_cols['éŸ³æ¨™'], edit_input)
            for line in results:
                print(line)
            for line in errors:
                print(line)
            if results:
                df_xlsx.to_excel(path, index=False)
                print(f"âœ… å·²æ›´æ–° Excelï¼š{path}")
                æª¢æŸ¥è³‡æ–™æ ¼å¼(df_xlsx, actual_cols['æ¼¢å­—'], actual_cols['éŸ³æ¨™'], False)

        # ğŸ” ç¬¬äºŒéšæ®µï¼šè™•ç† tone æ›¿æ›æŒ‡ä»¤
        # åˆæ¬¡é¡¯ç¤ºèª¿å€¼
        æ•´ç†ä¸¦é¡¯ç¤ºèª¿å€¼(df_xlsx, actual_cols)
        while True:
            user_input = input("\nğŸ”„ è¼¸å…¥æ›¿æ›æŒ‡ä»¤ï¼Œå¯ç”¨åˆ†è™Ÿåˆ†éš”å¤šæ¢ï¼ŒæŒ‰ Enter è·³éæ­¤æª”æ¡ˆï¼š").strip()
            if not user_input:
                break  # æŒ‰ Enter â†’ è™•ç†ä¸‹ä¸€å€‹æ–‡ä»¶

            commands = [cmd.strip() for cmd in user_input.split(";") if cmd.strip()]
            if len(commands) > 50:
                print("âš ï¸ æœ€å¤šä¸€æ¬¡åªèƒ½è¼¸å…¥ 50 æ¢æŒ‡ä»¤ï¼Œè«‹æ‹†é–‹ä¾†åŸ·è¡Œ")
                continue

            all_updated_rows = []
            valid = True

            for command in commands:
                match = re.match(r"([rs])(\d{1,4})>(\d{1,4})", command)
                if not match:
                    print(f"âŒ ç„¡æ•ˆæ ¼å¼ï¼š{command}ï¼Œè«‹ä½¿ç”¨é¡ä¼¼ r031>3 æˆ– s25>55")
                    valid = False
                    break
                mode, from_tone, to_tone = match.groups()

                updated_rows = []
                for i, row in df_xlsx.iterrows():
                    ipa = row[actual_cols['éŸ³æ¨™']]
                    hanzi = row[actual_cols['æ¼¢å­—']]
                    match_tone = re.search(r"([0-9Â¹Â²Â³â´âµâ¶â·â¸â¹â°]{1,4})$", str(ipa))
                    if not match_tone:
                        # print(f"âš ï¸ æŒ‡ä»¤ {command}ï¼šæ²’æœ‰æ‰¾åˆ°å¯æ›¿æ›çš„é …ç›®")
                        continue

                    tone_raw = match_tone.group(1)
                    tone = tone_raw.translate(SUPER_TO_NORMAL)
                    head = ipa[:-len(tone_raw)]
                    prev_char = head[-1] if head else ""
                    ends_with_ru = prev_char in RU_FINALS

                    if mode == 'r' and ends_with_ru and tone == from_tone:
                        new_ipa = head + to_tone
                        df_xlsx.at[i, actual_cols['éŸ³æ¨™']] = new_ipa
                        updated_rows.append((hanzi, ipa, new_ipa))

                    elif mode == 's' and not ends_with_ru and tone == from_tone:
                        new_ipa = head + to_tone
                        df_xlsx.at[i, actual_cols['éŸ³æ¨™']] = new_ipa
                        updated_rows.append((hanzi, ipa, new_ipa))

                if not updated_rows:
                    print(f"âš ï¸ æŒ‡ä»¤ {command}ï¼šæ²’æœ‰æ‰¾åˆ°å¯æ›¿æ›çš„é …ç›®")
                else:
                    all_updated_rows.extend(updated_rows)

            if not valid:
                continue  # æ ¼å¼éŒ¯èª¤ï¼Œé‡è¼¸æ•´æ‰¹

            if not all_updated_rows:
                print("âš ï¸ æ²’æœ‰ä»»ä½•æ›¿æ›æˆåŠŸï¼Œè«‹é‡æ–°è¼¸å…¥æŒ‡ä»¤")
                continue

            print(f"\nâœ… æ›¿æ›çµæœï¼ˆ{len(all_updated_rows)} æ¢ï¼‰ï¼š")
            for hanzi, old, new in all_updated_rows:
                print(f"{hanzi}\t{old} â†’ {new}")

            df_xlsx.to_excel(path, index=False)
            print(f"âœ… å·²å¯«å…¥ï¼š{path}")

            # å†æ¬¡é¡¯ç¤ºèª¿å€¼
            print("\nğŸ“Š ç•¶å‰èª¿å€¼æ•´ç†ï¼š")
            æ•´ç†ä¸¦é¡¯ç¤ºèª¿å€¼(df_xlsx, actual_cols)

        print("ğŸ”é–‹å§‹åˆ†åˆ¥æå–è²æ¯éŸ»æ¯")

        # ğŸ” ç¬¬ä¸‰éšæ®µï¼šè™•ç†é›¶è²æ¯
        df = extract_all_from_files(path, False, True)
        # print(df)
        # print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")

        # éæ¿¾å£°æ¯ç‚º "/" ä¸”éŸµæ¯ä»¥ i/y/u é–‹é ­
        filtered_df = df[(df["å£°æ¯"] == "/") & (df["éŸµæ¯"].str.startswith(tuple(["i", "y", "u"])))]

        # æŸ¥æ‰¾é»å”‡é½¿å£°æ¯ï¼ˆå®Œå…¨åŒ¹é…ï¼‰
        labiodental_onsets = ["w", "v", "Ê‹", "â±±", "Ê·", "áµ›", "á¶¹"]
        labiodental_df = df[df["å£°æ¯"].isin(labiodental_onsets)]

        if not labiodental_df.empty:
            found_labiodentals = labiodental_df["å£°æ¯"].unique()
            print(f"è¯¥é»å”‡é½¿å£°æ¯ä¸ºï¼š{', '.join(found_labiodentals)}")

        # æŸ¥æ‰¾å–‰å¡éŸ³å£°æ¯
        glottal_onsets = ["Ê”", "Ë€", "Ã¸", "(Ê”)", "Ç¾", "âˆ…"]
        glottal_df = df[df["å£°æ¯"].isin(glottal_onsets)]
        get_j = ["j"]
        get_j_df = df[df["å£°æ¯"].isin(get_j)]

        if not glottal_df.empty:
            found_onsets = glottal_df["å£°æ¯"].unique()
            found_rimes = glottal_df["éŸµæ¯"].unique()
            found_onsets2 = get_j_df["å£°æ¯"].unique()
            found_rimes2 = get_j_df["éŸµæ¯"].unique()
            print(f"æœ‰å–‰å¡éŸ³å£°æ¯ {', '.join(found_onsets)}ï¼Œå¯ä»¥ä¸ {', '.join(found_rimes)} æ­é…")
            print(f"æœ‰ç¡¬è…­å£°æ¯ {', '.join(found_onsets2)}ï¼Œå¯ä»¥ä¸ {', '.join(found_rimes2)} æ­é…")
        else:
            print("è¯¥è¡¨æ²¡æœ‰å¯¹é›¶å£°æ¯è¿›è¡Œå¤„ç†ï¼")

        # å…ˆä¿å­˜åŸå§‹è¡Œè™Ÿï¼ˆçœŸæ­£ä¿ç•™ df çš„ indexï¼‰
        filtered_df = filtered_df.copy()
        filtered_df["åŸå§‹è¡Œè™Ÿ"] = filtered_df.index

        # ç”¨ sorted æ’å‡ºæ­£ç¢ºé †åº
        sorted_rows = sorted(filtered_df.to_dict("records"), key=lambda row: rime_sort_key(row["éŸµæ¯"]))

        # å»ºç«‹æ’åºå¾Œ DataFrameï¼Œä¿ç•™åŸå§‹è¡Œè™Ÿ
        filtered_df = pd.DataFrame(sorted_rows).reset_index(drop=True)

        # é¡¯ç¤ºæ’åºå¾Œçµæœï¼ˆä¸é¡¯ç¤º DataFrame indexï¼‰
        print(filtered_df)

        # âœï¸ ä½¿ç”¨è€…ç·¨è¼¯æŒ‡ä»¤ä»‹é¢
        while True:
            edit_input = input("\nâœï¸ è¼¸å…¥ç·¨è¼¯æŒ‡ä»¤ ï¼ŒæŒ‰ Enter è·³éï¼š").strip().replace("\n", "")
            if not edit_input:
                break

            results, errors = è™•ç†æ‰¹æ¬¡ç·¨è¼¯æŒ‡ä»¤(
                df_xlsx,
                filtered_df,
                actual_cols,
                edit_input
            )

            for line in results:
                print(line)
            for line in errors:
                print(line)

            if results:
                df_xlsx.to_excel(path, index=False)
                print(f"âœ… å·²æ›´æ–° Excelï¼š{path}")

                # é‡æ–°è®€å…¥æ›´æ–°å¾Œè³‡æ–™
                df = extract_all_from_files(path, False, True)
                # æŸ¥æ‰¾å–‰å¡éŸ³å£°æ¯
                glottal_onsets = ["Ê”", "Ë€", "Ã¸", "(Ê”)", "Ç¾", "âˆ…"]
                glottal_df = df[df["å£°æ¯"].isin(glottal_onsets)]
                if not glottal_df.empty:
                    found_onsets = glottal_df["å£°æ¯"].unique()
                    found_rimes = glottal_df["éŸµæ¯"].unique()
                    print(f"æœ‰å–‰å¡éŸ³å£°æ¯ {', '.join(found_onsets)}ï¼Œå¯ä»¥ä¸ {', '.join(found_rimes)} æ­é…")
                else:
                    print("è¯¥è¡¨æ²¡æœ‰å¯¹é›¶å£°æ¯è¿›è¡Œå¤„ç†ï¼")
                # å…ˆä¿å­˜åŸå§‹è¡Œè™Ÿï¼ˆçœŸæ­£ä¿ç•™ df çš„ indexï¼‰
                filtered_df = df[(df["å£°æ¯"] == "/") & (df["éŸµæ¯"].str.startswith(tuple(["i", "y", "u"])))]
                filtered_df = filtered_df.copy()
                filtered_df["åŸå§‹è¡Œè™Ÿ"] = filtered_df.index

                # ç”¨ sorted æ’å‡ºæ­£ç¢ºé †åº
                sorted_rows = sorted(filtered_df.to_dict("records"), key=lambda row: rime_sort_key(row["éŸµæ¯"]))

                # å»ºç«‹æ’åºå¾Œ DataFrameï¼Œä¿ç•™åŸå§‹è¡Œè™Ÿ
                filtered_df = pd.DataFrame(sorted_rows).reset_index(drop=True)
                print(filtered_df)

        # ğŸ” ç¬¬å››éšæ®µï¼šè™•ç†ä¸è©²å‡ºç¾çš„è²éŸ»å°ç«‹
        df = extract_all_from_files(path, False, True)
        # çµ±è¨ˆå£°æ¯èˆ‡éŸµæ¯
        print("\nğŸ”¢ ã€å£°æ¯ã€çµ±è¨ˆï¼š")
        print_counts_in_rows(sort_by_custom_order(df["å£°æ¯"]))
        print("\nğŸ”¢ ã€éŸµæ¯ã€çµ±è¨ˆï¼š")
        print_counts_in_rows(sort_by_custom_order(df["éŸµæ¯"]))

        while True:
            # ğŸ” æŸ¥è©¢å¾ªç’°
            user_query = input("\nğŸ” è¼¸å…¥è¦æŸ¥æ‰¾çš„ã€å£°æ¯ã€æˆ–ã€éŸµæ¯ã€å€¼ï¼ˆç©ºæ ¼åˆ†éš”ï¼ŒæŒ‰ Enter æŸ¥è©¢ï¼‰ï¼š").strip()
            if not user_query:
                print("ğŸ‘‹ çµæŸæŸ¥è©¢ã€‚")
                break

            # æ”¯æ´å¤šå€‹æŸ¥è©¢è©
            query_tokens = user_query.split()

            # åœ¨ã€Œå£°æ¯ã€æˆ–ã€ŒéŸµæ¯ã€ä¸­åŒ¹é…ä»»ä¸€é …
            matched_df = df[
                df["å£°æ¯"].isin(query_tokens) | df["éŸµæ¯"].isin(query_tokens)
                ].reset_index().rename(columns={"index": "åŸå§‹è¡Œè™Ÿ"})

            if matched_df.empty:
                print(f"âŒ æ‰¾ä¸åˆ°ã€{user_query}ã€ç›¸é—œè³‡æ–™")
                continue

            print("\nğŸ“‹ æŸ¥è©¢çµæœï¼š")
            print(matched_df)

            edit_input = input("\nâœï¸ è¼¸å…¥ç·¨è¼¯æŒ‡ä»¤ï¼ˆä¾‹å¦‚ï¼š0~1 y>iï¼‰ï¼ŒæŒ‰ Enter å›åˆ°æŸ¥è©¢ï¼š").strip()
            if not edit_input:
                print("ğŸ” å›åˆ°æŸ¥è©¢ä»‹é¢ã€‚")
                continue

            results, errors = è™•ç†æ‰¹æ¬¡ç·¨è¼¯æŒ‡ä»¤(
                df_xlsx,
                matched_df,
                actual_cols,  # è¦–ä½ çš„è¡¨æ ¼æ¬„ä½åç¨±èª¿æ•´
                edit_input
            )

            for line in results:
                print(line)
            for line in errors:
                print(line)

            if results:
                df_xlsx.to_excel(path, index=False)
                print(f"âœ… å·²æ›´æ–° Excelï¼š{path}")

                df = extract_all_from_files(path, False, True)
                print("\nğŸ”¢ ã€å£°æ¯ã€çµ±è¨ˆï¼š")
                print_counts_in_rows(sort_by_custom_order(df["å£°æ¯"]))
                print("\nğŸ”¢ ã€éŸµæ¯ã€çµ±è¨ˆï¼š")
                print_counts_in_rows(sort_by_custom_order(df["éŸµæ¯"]))

        # ğŸ” ç¬¬äº”éšæ®µï¼šè™•ç†å‡ºéŸ»å­—
        if not five:
            continue
        results1 = check_get_chars(df, "å£°æ¯")
        results2 = check_get_chars(df, "éŸµæ¯")
        results = results1 + results2
        all_unique_chars = set()
        for result_df in results:
            if not result_df.empty:
                # æå–"å°æ‡‰å­—"åˆ—å¹¶å°†æ‰€æœ‰å­—åˆå¹¶åˆ°ä¸€ä¸ªé›†åˆä¸­
                for chars_list in result_df['å°æ‡‰å­—']:
                    all_unique_chars.update(chars_list)  # å°†æ¯ä¸ªå­—æ·»åŠ åˆ°é›†åˆä¸­

        # å°†é›†åˆè½¬æ¢ä¸ºåˆ—è¡¨ï¼Œå»é‡åçš„å­—å°†æˆä¸ºåˆ—è¡¨çš„å…ƒç´ 
        chars_list = list(all_unique_chars)
        # print(chars_list)
        æŸ¥æ‰¾å‡ºéŸ»å­—(df_xlsx, actual_cols, chars_list)

        while True:
            edit_input = input("\nâœï¸ è¼¸å…¥ç·¨è¼¯æŒ‡ä»¤ ï¼ŒæŒ‰ Enter è·³éï¼š").strip()
            if not edit_input:
                break
            results, errors = è™•ç†è‡ªå®šç¾©ç·¨è¼¯æŒ‡ä»¤(df_xlsx, actual_cols['æ¼¢å­—'], actual_cols['éŸ³æ¨™'], edit_input)
            for line in results:
                print(line)
            for line in errors:
                print(line)
            if results:
                df_xlsx.to_excel(path, index=False)
                print(f"âœ… å·²æ›´æ–° Excelï¼š{path}")
                æŸ¥æ‰¾å‡ºéŸ»å­—(df_xlsx, actual_cols, chars_list)


def tsv_to_xlsx(tsv_path, output_path=None):
    if not os.path.exists(tsv_path):
        print(f"[âŒ] æ‰¾ä¸åˆ°æª”æ¡ˆï¼š{tsv_path}")
        return

    df = pd.read_csv(tsv_path, sep="\t", dtype=str)

    if output_path is None:
        output_path = os.path.splitext(tsv_path)[0] + ".xlsx"

    df.to_excel(output_path, index=False)
    print(f"[âœ…] è½‰æ›å®Œæˆï¼š{output_path}")


def check_pro(mode='only'):
    root = tk.Tk()
    root.withdraw()
    pd.set_option('display.max_rows', None)
    pd.set_option('display.max_columns', None)
    pd.set_option('display.max_colwidth', None)

    five = True

    if mode == 'only':
        xlsx_paths = filedialog.askopenfilenames(
            title="é¸æ“‡å¤šå€‹ Excel æ–‡ä»¶",
            filetypes=[("Excel Files", "*.xlsx")]
        )
        check_all(xlsx_paths)
    else:
        file_paths = filedialog.askopenfilenames(
            title="é¸æ“‡æ–‡ä»¶",
            filetypes=[
                ("æ”¯æŒæ ¼å¼", "*.xlsx *.xls *.doc *.docx *.tsv"),
                ("Excel æ–‡ä»¶", "*.xlsx *.xls"),
                ("Word æ–‡ä»¶", "*.doc *.docx"),
                ("TSV æ–‡ä»¶", "*.tsv"),
                ("æ‰€æœ‰æ–‡ä»¶", "*.*")
            ]
        )

        print(file_paths)
        for path in file_paths:
            ext = os.path.splitext(path)[1].lower()
            if ext == ".tsv":
                tsv_to_xlsx(path, path)
            elif ext in (".doc", ".docx"):
                process_ç¸£å¿—_word(path, level=1)
                tsv_path = os.path.splitext(path)[0] + ".tsv"
                if os.path.exists(tsv_path):
                    xlsx_path = os.path.splitext(path)[0] + ".xlsx"
                    tsv_to_xlsx(tsv_path, xlsx_path)
                    check_all([xlsx_path], five)

            elif ext in (".xlsx", ".xls"):
                try:
                    df = pd.read_excel(path, dtype=str)
                except Exception as e:
                    print(f"[âŒ] ç„¡æ³•è®€å–ï¼š{path}\nåŸå› ï¼š{e}")
                    continue

                df_cols = df.columns.tolist()

                mapped_cols = {}
                for std_col, variants in col_map.items():
                    for v in variants:
                        if v in df_cols:
                            mapped_cols[std_col] = v
                            break

                # å¦‚æœä¸‰å€‹æ¨™æº–æ¬„ä½éƒ½æ‰¾åˆ°ï¼Œå°± rename ä¸¦åŸ·è¡Œ check_all
                if set(mapped_cols.keys()) >= {"æ¼¢å­—", "éŸ³æ¨™", "è§£é‡‹"}:
                    # df = df.rename(columns={v: k for k, v in mapped_cols.items()})
                    check_all([path], five)
                else:
                    required_cols = ["æ¼¢å­—", "éŸ³æ¨™", "è§£é‡‹"]
                    print(mapped_cols)
                    missing = [col for col in required_cols if col not in mapped_cols]
                    if missing:
                        print(f"âŒ ç¼ºå°‘æ¬„ä½ï¼š{missing}ï¼Œæ˜¯å¦ç‚ºç¸£å¿—/è·³è·³è€é¼ æ ¼å¼ï¼Ÿ")
                        print("è‹¥æ˜¯è·³è·³è€é¼ ï¼Œè«‹è¼¸å…¥1\nè‹¥æ˜¯ç¸£å¿—ï¼Œè«‹è¼¸å…¥2")
                        while True:
                            user_input = input("è«‹è¼¸å…¥ (1 æˆ– 2)ï¼š").strip()
                            if user_input == "1":
                                print("ğŸ‘‰ ä½¿ç”¨è·³è·³è€é¼ æ ¼å¼é‚è¼¯")
                                process_è·³è·³è€é¼ (path, level=1)
                                tsv_path = os.path.splitext(path)[0] + ".tsv"
                                if os.path.exists(tsv_path):
                                    xlsx_path = os.path.splitext(path)[0] + "pro" + ".xlsx"
                                    tsv_to_xlsx(tsv_path, xlsx_path)
                                    check_all([xlsx_path], five)
                                break
                            elif user_input == "2":
                                print("ğŸ‘‰ ä½¿ç”¨ç¸£å¿—æ ¼å¼é‚è¼¯")
                                process_ç¸£å¿—_excel(path, level=1)
                                tsv_path = os.path.splitext(path)[0] + ".tsv"
                                if os.path.exists(tsv_path):
                                    xlsx_path = os.path.splitext(path)[0] + "pro" + ".xlsx"
                                    tsv_to_xlsx(tsv_path, xlsx_path)
                                    check_all([xlsx_path], five)
                                break
                            else:
                                print("âš ï¸ è«‹è¼¸å…¥æ­£ç¢ºçš„æ•¸å­—ï¼ˆ1 æˆ– 2ï¼‰")


if __name__ == "__main__":
    mode = 'only'
    check_pro(mode)
